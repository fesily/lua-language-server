# 长话短说
服务器的启动时间正比于你工作区中所有Lua文件的总大小，因此最有效的方式是使用设置 `workspace.ignoreDir` 来排除非必要的目录与文件。

# 加载时间分析
我使用了一个包含1500个Lua文件，总大小为20MB的真实项目进行了测试。
我的测试CPU为 `i7-9700K` ，项目文件放在HDD中，插件本身放在SSD中。

经过多次测试，20MB文件的 `加载工作区` 耗时约为10秒，即 `2MB/S` 的加载速度。

1. 初始化服务器，与客户端握手并读取配置：0.5秒
2. 扫描工作区中的文件，找出所有Lua文件路径：0.25秒
3. `加载工作区` 开始，把Lua文件的内容读进内存：1.5秒
4. 把Lua文件的内容编译为语法树：6.5秒
5. 根据语法树收集文件中的全局变量等信息：1秒
6. 其他的时间花费：1秒
7. `加载工作区` 结束，可以使用了。

> 由于我进行了多次测试，而操作系统会在一定程度上缓存运算结果与文件读取，因此他们的测试表现会好于实际表现。

> 第2步扫描文件受到你工作区中总文件数量的影响（包括非Lua文件）。

> 实际工作时，第2步与第3步会同时进行，可以加快0.5秒左右。

根据测试，最耗时的部分为“将Lua文件编译为语法树”。这个时间符合预期，因此可能没有什么改进空间了。
正如之前所说的，最好的办法是通过设置排除掉无用的目录与文件，不要加载无用的`library`。

# 多进度条/单文件模式相关
在阅读接下来的内容之前，请先看一下 https://github.com/sumneko/lua-language-server/wiki/Multi-workspace-supports

当你以单文件模式启动服务器时，服务器只会创建 `<fallback>` Scope，所有的Lua文件都在此处理。

当你以工作区模式启动服务器时，服务器实际上会创建2个Scope，一个是你的工作区，另一个被称为 `<fallback>` 。当你临时打开一个不属于工作区的Lua文件时，该文件会被放置到 `<fallback>` 中，以免该文件的全局变量污染你的工作区环境。

由于我的开发环境是VSCode，而VSCode可以简单的为不同的工作区进行不同的设置，因此我做出了以下假设：
* 用户会给工作区单独设置 `workspace.library`，因为Lua的能力主要由宿主提供，而不同的工作区一般会对应不同的宿主
* 用户不会给全局设置 `workspace.library` ，因为它的主要目的是快速的看一下某个环境未知/不需要环境的Lua代码。

但最近的用户反馈让我发现了一个问题，在非VSCode环境中用户不方便给每个工作区进行单独设置（虽然我也提供了 `.luarc.json` 的方式），很多人直接会在全局设置中设置 `workspace.library`，当 library 较大时导致了一些问题：
* 以单文件模式启动服务器时，启动速度会被 library 影响，导致你明明只是想快速的看一下某一段Lua代码，却需要等待漫长的加载时间。
* 以工作区模式启动服务器时，会看到多个进度条。如果 `<fallback>` 只需要加载基础的Lua API通常可以在0.5秒内完成（进度条有0.5秒的显示延迟），这使得你不会看到 `<fallback>` 的加载进度条。但 `<fallback>` 受到 library 影响后也需要加载很多文件，这导致你会看到多个进度条。不过这不会影响实际的加载速度，因为同一个文件只会被加载一次。

介于这个情况，我在考虑添加一个默认开启的设置，使得 `<fallback>` 可以忽略 `workspace.library` 。